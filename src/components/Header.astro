---
import profile from '../data/profile.json';
---

<div class="header">
    <!-- ASCII Canvas Container -->
    <div class="ascii-canvas-container">
        <canvas id="ascii-canvas"></canvas>
        <div class="vim-mode digital-only" id="vimMode">NORMAL</div>
    </div>
    
    <!-- System Info -->
    <div class="system-info">
        <span>USER: {profile.personal.name}</span>
        <span>STATUS: System Architect</span>
        <span>DATE: <span id="current-date"></span></span>
    </div>
</div>

<script>
  const dateElement = document.getElementById('current-date');
  if (dateElement) {
    dateElement.textContent = new Date().toISOString().slice(0, 10);
  }
</script>

<style>
.header {
    position: relative;
    margin-bottom: 40px;
}

/* ASCII Canvas Container */
.ascii-canvas-container {
    position: relative;
    width: 100%;
    height: 180px;
    margin-bottom: 20px;
}

body.print-view .ascii-canvas-container {
    height: 180px;
    margin-bottom: 20px;
    display: block !important;
}

#ascii-canvas {
    width: 100%;
    height: 100%;
    display: block;
}

body.print-view #ascii-canvas {
    filter: none !important;
    opacity: 1 !important;
    display: block !important;
}

/* Vim Mode Indicator */
.vim-mode {
    position: absolute;
    bottom: 10px;
    right: 10px;
    font-size: 10px;
    color: var(--muted-digital);
    font-family: var(--font-body);
    letter-spacing: 1px;
    padding: 2px 6px;
    border: 1px solid var(--border-digital);
    background: var(--accent-digital);
    transition: all 0.3s ease;
    z-index: 10;
}

.vim-mode.insert {
    color: #8ec07c;
    border-color: #8ec07c;
    background: rgba(142, 192, 124, 0.1);
}

.vim-mode.visual {
    color: #83a598;
    border-color: #83a598;
    background: rgba(131, 165, 152, 0.1);
}

.vim-mode.command {
    color: #ff4444;
    border-color: #ff4444;
    background: rgba(255, 68, 68, 0.1);
}

/* Cursor styles based on vim mode */
body.digital-view {
    cursor: crosshair;
}

body.digital-view.vim-normal {
    cursor: crosshair;
}

body.digital-view.vim-insert {
    cursor: text;
}

body.digital-view.vim-visual {
    cursor: cell;
}

body.digital-view.vim-command {
    cursor: help;
}

/* Remove print ASCII name styles since we're using canvas for both modes */

/* System Info */
.system-info {
    display: flex;
    flex-direction: column;
    gap: 5px;
    font-size: 12px;
    color: var(--muted-digital);
    margin-top: 20px;
}

body.print-view .system-info {
    color: var(--muted-print);
}

/* Digital/Print View Toggles */
body.print-view .digital-only {
    display: none;
}
</style>

<script is:inline>
class SimpleASCIICanvas {
    constructor() {
        this.canvas = document.getElementById('ascii-canvas');
        if (!this.canvas) return;
        
        this.ctx = this.canvas.getContext('2d');
        this.time = 0;
        this.mousePos = { x: 0, y: 0 };
        this.currentMode = 'NORMAL';
        this.particles = [];
        this.currentEffect = 0;
        this.effectNames = [
            'Matrix Rain',
            'Blockchain Validation', 
            'Real-time Trading',
            'AES Encryption',
            'Distributed Ledger',
            'SWIFT Network',
            'Risk Assessment',
            'Compliance Check',
            'Trade Settlement',
            'Typing Animation',
            'Visual Selection',
            'Syntax Highlight'
        ];
        
        this.colorSchemes = [
            'scheme-matrix',
            'scheme-blockchain',
            'scheme-trading',
            'scheme-encryption',
            'scheme-ledger',
            'scheme-swift',
            'scheme-risk',
            'scheme-compliance',
            'scheme-settlement',
            'scheme-gruvbox',
            'scheme-gruvbox-visual',
            'scheme-gruvbox-syntax'
        ];
        
        this.ASCII_NAME = `█████╗ ██╗     ██╗      █████╗ ██╗      ██████╗  █████╗ ████████╗████████╗ █████╗ ███╗   ██╗
██╔══██╗██║     ██║     ██╔══██╗██║     ██╔═══██╗██╔══██╗╚══██╔══╝╚══██╔══╝██╔══██╗████╗  ██║
███████║██║     ██║     ███████║██║     ██║   ██║███████║   ██║      ██║   ███████║██╔██╗ ██║
██╔══██║██║     ██║     ██╔══██║██║     ██║▄▄ ██║██╔══██║   ██║      ██║   ██╔══██║██║╚██╗██║
██║  ██║███████╗██║     ██║  ██║███████╗╚██████╔╝██║  ██║   ██║      ██║   ██║  ██║██║ ╚████║
╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝  ╚═╝╚══════╝ ╚══▀▀═╝ ╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝`;
        
        this.init();
    }
    
    init() {
        this.resize();
        this.createParticles();
        
        // Set initial vim mode class
        document.body.classList.add('vim-normal');
        
        // Set initial color scheme
        this.updateColorScheme();
        
        window.addEventListener('resize', () => this.resize());
        this.canvas.addEventListener('mousemove', (e) => this.updateMouse(e));
        document.addEventListener('keydown', (e) => this.handleKeydown(e));
        
        this.animate();
    }
    
    resize() {
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        this.createParticles();
    }
    
    createParticles() {
        this.particles = [];
        const fontSize = 12;
        const lines = this.ASCII_NAME.split('\n');
        const lineHeight = fontSize * 1.2;
        const totalWidth = lines[0].length * (fontSize * 0.6);
        const startX = (this.canvas.width - totalWidth) / 2;
        const startY = 30;
        
        lines.forEach((line, lineIndex) => {
            for (let charIndex = 0; charIndex < line.length; charIndex++) {
                const char = line[charIndex];
                if (char !== ' ') {
                    const x = startX + charIndex * (fontSize * 0.6);
                    const y = startY + lineIndex * lineHeight;
                    
                    this.particles.push({
                        char,
                        originalChar: char,
                        x, y,
                        baseX: x, baseY: y,
                        offsetX: 0, offsetY: 0,
                        opacity: 0,
                        targetOpacity: 1,
                        color: '#00ff41',
                        typed: false,
                        index: this.particles.length,
                        phase: Math.random() * Math.PI * 2,
                        blockIndex: Math.floor(charIndex / 8),
                        validated: false,
                        price: Math.random() * 1000 + 100,
                        trend: Math.random() > 0.5 ? 1 : -1,
                        riskLevel: Math.random(),
                        highlighted: false
                    });
                }
            }
        });
    }
    
    updateMouse(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos.x = e.clientX - rect.left;
        this.mousePos.y = e.clientY - rect.top;
    }
    
    handleKeydown(e) {
        if (!document.body.classList.contains('digital-view')) return;
        
        if (e.key === 'Escape') this.currentMode = 'NORMAL';
        else if (this.currentMode === 'NORMAL') {
            if (e.key === 'i') this.currentMode = 'INSERT';
            else if (e.key === 'v') this.currentMode = 'VISUAL';
            else if (e.key === ':') this.currentMode = 'COMMAND';
            else if (e.key === 'n') {
                this.currentEffect = (this.currentEffect + 1) % this.effectNames.length;
                this.resetParticleStates();
                this.updateColorScheme();
            }
            else if (e.key === 'p') {
                this.currentEffect = (this.currentEffect - 1 + this.effectNames.length) % this.effectNames.length;
                this.resetParticleStates();
                this.updateColorScheme();
            }
        }
        
        const modeElement = document.getElementById('vimMode');
        if (modeElement) {
            modeElement.textContent = `${this.currentMode} - ${this.effectNames[this.currentEffect]}`;
            modeElement.className = `vim-mode ${this.currentMode.toLowerCase()}`;
        }
        
        // Update body class for cursor styling
        document.body.className = document.body.className.replace(/\bvim-\w+\b/g, '');
        document.body.classList.add(`vim-${this.currentMode.toLowerCase()}`);
    }
    
    resetParticleStates() {
        this.particles.forEach(p => {
            p.validated = false;
            p.offsetX = 0;
            p.offsetY = 0;
            p.highlighted = false;
            p.trend = Math.random() > 0.5 ? 1 : -1;
            p.price = Math.random() * 1000 + 100;
            p.riskLevel = Math.random();
        });
        this.time = 0;
    }
    
    updateColorScheme() {
        // Remove all existing scheme classes
        this.colorSchemes.forEach(scheme => {
            document.body.classList.remove(scheme);
        });
        
        // Apply the current scheme
        const currentScheme = this.colorSchemes[this.currentEffect];
        document.body.classList.add(currentScheme);
    }
    
    animate() {
        this.time++;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Render particles in both digital and print mode
        this.renderParticles();
        
        requestAnimationFrame(() => this.animate());
    }
    
    renderParticles() {
        this.ctx.font = '12px monospace';
        const isPrintMode = !document.body.classList.contains('digital-view');
        
        this.particles.forEach((particle, index) => {
            const distance = Math.sqrt(
                Math.pow(this.mousePos.x - particle.baseX, 2) + 
                Math.pow(this.mousePos.y - particle.baseY, 2)
            );

            // Type-in effect
            if (!particle.typed && this.time > index * 2) {
                particle.typed = true;
                particle.targetOpacity = 1;
            }

            particle.opacity += (particle.targetOpacity - particle.opacity) * 0.1;

            // Set base color and effects based on vim mode and print mode
            if (isPrintMode) {
                // Print mode: static black text, no effects
                particle.color = '#000000';
                particle.offsetX = 0;
                particle.offsetY = 0;
                // Ensure full opacity for print mode
                particle.targetOpacity = 1;
            } else {
                // Digital mode: apply current effect
                this.applyCurrentEffect(particle, index, distance);
            }

            this.ctx.fillStyle = particle.color;
            this.ctx.globalAlpha = particle.opacity;
            this.ctx.fillText(
                particle.char,
                particle.baseX + particle.offsetX,
                particle.baseY + particle.offsetY
            );
        });
        
        this.ctx.globalAlpha = 1;
    }
    
    applyCurrentEffect(particle, index, distance) {
        const time = this.time;
        const isHovering = distance < 30;
        
        switch(this.currentEffect) {
            case 0: // Matrix Rain
                particle.offsetY = Math.sin(time * 0.02 + index * 0.05) * 0.5;
                particle.color = isHovering ? '#fabd2f' : '#00ff41';
                if (isHovering) {
                    particle.offsetX = Math.sin(time * 0.05 + index) * 2;
                } else {
                    particle.offsetX *= 0.9;
                }
                break;
                
            case 1: // Blockchain Validation
                if (isHovering) {
                    const validationDelay = particle.blockIndex * 10;
                    if (time > validationDelay) {
                        particle.validated = true;
                        const hashChars = ['0', '1', 'a', 'b', 'c', 'd', 'e', 'f'];
                        particle.char = hashChars[Math.floor(Math.random() * hashChars.length)];
                        particle.color = '#00d4aa';
                    } else {
                        particle.color = '#666666';
                    }
                } else {
                    particle.validated = false;
                    particle.char = particle.originalChar;
                    particle.color = '#ffffff';
                }
                break;
                
            case 2: // Real-time Trading
                particle.phase += 0.1;
                if (isHovering) {
                    particle.price += (Math.random() - 0.5) * 10 * particle.trend;
                    particle.offsetY = Math.sin(particle.phase) * (particle.price / 50);
                    const priceChars = ['$', '€', '¥', '£', '+', '-', '↑', '↓'];
                    particle.char = priceChars[Math.floor(Math.random() * priceChars.length)];
                    particle.color = particle.trend > 0 ? '#00ff88' : '#ff4444';
                } else {
                    particle.offsetY *= 0.9;
                    particle.char = particle.originalChar;
                    particle.color = '#ffffff';
                }
                break;
                
            case 3: // AES Encryption
                if (isHovering) {
                    const encryptionSteps = ['S', 'R', 'M', 'K'];
                    const step = Math.floor(time / 20) % encryptionSteps.length;
                    particle.char = encryptionSteps[step];
                    particle.offsetX = Math.sin(time * 0.2 + index) * 5;
                    particle.color = '#ffaa00';
                } else {
                    particle.char = particle.originalChar;
                    particle.offsetX *= 0.9;
                    particle.color = '#ffffff';
                }
                break;
                
            case 4: // Distributed Ledger
                if (isHovering) {
                    const syncDelay = index * 3;
                    if ((time + syncDelay) % 60 < 30) {
                        particle.char = '█';
                        particle.color = '#00d4aa';
                    } else {
                        particle.char = '░';
                        particle.color = '#666666';
                    }
                } else {
                    particle.char = particle.originalChar;
                    particle.color = '#ffffff';
                }
                break;
                
            case 5: // SWIFT Network
                if (isHovering) {
                    const routingChars = ['MT', '10', '20', '30', '50', '59', '71'];
                    particle.char = routingChars[Math.floor(time / 15) % routingChars.length];
                    particle.offsetX = Math.cos(time * 0.1 + index) * 15;
                    particle.offsetY = Math.sin(time * 0.1 + index) * 8;
                    particle.color = '#0088ff';
                } else {
                    particle.char = particle.originalChar;
                    particle.offsetX *= 0.9;
                    particle.offsetY *= 0.9;
                    particle.color = '#ffffff';
                }
                break;
                
            case 6: // Risk Assessment
                particle.phase += 0.15;
                if (isHovering) {
                    const riskLevel = Math.sin(particle.phase) * 0.5 + 0.5;
                    const riskChars = ['!', '?', '%', '∆', '∑', '∏'];
                    particle.char = riskChars[Math.floor(riskLevel * riskChars.length)];
                    if (riskLevel > 0.7) {
                        particle.color = '#ff4444';
                        particle.offsetX = (Math.random() - 0.5) * 6;
                    } else if (riskLevel > 0.4) {
                        particle.color = '#ffaa00';
                    } else {
                        particle.color = '#00ff88';
                    }
                } else {
                    particle.char = particle.originalChar;
                    particle.offsetX *= 0.9;
                    particle.color = '#ffffff';
                }
                break;
                
            case 7: // Compliance Check
                if (isHovering) {
                    const checkSteps = ['?', '...', '✓', '✗'];
                    const step = Math.floor((time + index * 10) / 30) % checkSteps.length;
                    particle.char = checkSteps[step];
                    if (step === 2) {
                        particle.color = '#00ff88';
                    } else if (step === 3) {
                        particle.color = '#ff4444';
                    } else {
                        particle.color = '#ffaa00';
                    }
                } else {
                    particle.char = particle.originalChar;
                    particle.color = '#ffffff';
                }
                break;
                
            case 8: // Trade Settlement
                if (isHovering) {
                    const settlementDay = Math.floor(time / 60) % 3;
                    const dayChars = ['T', '+1', '+2'];
                    particle.char = dayChars[settlementDay];
                    if (settlementDay === 2) {
                        particle.color = '#00ff88';
                        particle.offsetY = Math.sin(time * 0.3) * 5;
                    } else {
                        particle.color = '#ffaa00';
                        particle.offsetY *= 0.9;
                    }
                } else {
                    particle.char = particle.originalChar;
                    particle.offsetY *= 0.9;
                    particle.color = '#ffffff';
                }
                break;
                
            case 9: // Typing Animation
                if (isHovering) {
                    particle.offsetY = Math.sin(time * 0.1 + index * 0.1) * 2;
                    particle.color = '#8ec07c';
                } else {
                    particle.offsetY *= 0.9;
                    particle.color = '#ebdbb2';
                }
                break;
                
            case 10: // Visual Selection
                if (isHovering) {
                    particle.highlighted = true;
                    particle.color = '#d3869b';
                    // Draw selection background
                    this.ctx.fillStyle = 'rgba(211, 134, 155, 0.3)';
                    this.ctx.fillRect(
                        particle.baseX - 2,
                        particle.baseY - 12,
                        10,
                        16
                    );
                } else {
                    particle.highlighted = false;
                    particle.color = '#ebdbb2';
                }
                break;
                
            case 11: // Syntax Highlight
                if ('█▄▀'.includes(particle.char)) {
                    particle.color = isHovering ? '#8ec07c' : '#6c9f5c';
                } else if ('╗║╔═╚╝'.includes(particle.char)) {
                    particle.color = isHovering ? '#83a598' : '#638578';
                } else if ('░▒▓'.includes(particle.char)) {
                    particle.color = isHovering ? '#d3869b' : '#b3667b';
                } else {
                    particle.color = isHovering ? '#fabd2f' : '#ebdbb2';
                }
                if (isHovering) {
                    particle.offsetX = Math.sin(time * 0.05 + index) * 1;
                } else {
                    particle.offsetX *= 0.9;
                }
                break;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new SimpleASCIICanvas();
});
</script>
