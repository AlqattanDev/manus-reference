---
import profile from '../data/profile.json';
---

<div class="header">
    <button class="view-switcher" aria-label="Toggle print preview mode">
        <svg class="icon-digital" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
            <line x1="9" y1="9" x2="15" y2="15"/>
            <line x1="15" y1="9" x2="9" y2="15"/>
        </svg>
        <svg class="icon-print" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6,9 6,2 18,2 18,9"/>
            <path d="M6,18H4a2,2,0,0,1-2-2V11a2,2,0,0,1-2-2H20a2,2,0,0,1,2,2v5a2,2,0,0,1-2,2H18"/>
            <rect x="6" y="14" width="12" height="8"/>
        </svg>
    </button>

    <!-- Interactive ASCII Name Canvas -->
    <div class="ascii-name-container">
        <canvas id="name-canvas" class="ascii-name-canvas"></canvas>
        <div class="vim-mode digital-only" id="vimMode">NORMAL</div>
    </div>

    <!-- Print fallback - simple text -->
    <div class="ascii-name print-only">
        <h1>ALI AL QATTAN</h1>
    </div>

    <div class="system-info">
        <span>USER: {profile.personal.name}</span>
        <span>STATUS: System Architect</span>
        <span>DATE: <span id="current-date"></span></span>
    </div>
</div>

<script>
  const dateElement = document.getElementById('current-date');
  if (dateElement) {
    dateElement.textContent = new Date().toISOString().slice(0, 10);
  }
</script>

<script is:inline>
// Interactive ASCII Name Effect  
const ASCII_NAME = `
 █████╗ ██╗     ██╗      █████╗ ██╗      ██████╗  █████╗ ████████╗████████╗ █████╗ ███╗   ██╗
██╔══██╗██║     ██║     ██╔══██╗██║     ██╔═══██╗██╔══██╗╚══██╔══╝╚══██╔══╝██╔══██╗████╗  ██║
███████║██║     ██║     ███████║██║     ██║   ██║███████║   ██║      ██║   ███████║██╔██╗ ██║
██╔══██║██║     ██║     ██╔══██║██║     ██║▄▄ ██║██╔══██║   ██║      ██║   ██╔══██║██║╚██╗██║
██║  ██║███████╗██║     ██║  ██║███████╗╚██████╔╝██║  ██║   ██║      ██║   ██║  ██║██║ ╚████║
╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝  ╚═╝╚══════╝ ╚══▀▀═╝ ╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝
`.trim();

function initInteractiveASCII() {
    // Only run in digital mode
    if (!document.body.classList.contains('digital-view')) return;
    
    const canvas = document.getElementById('name-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const modeElement = document.getElementById('vimMode');
    
    let particles = [];
    const mousePosition = { x: 0, y: 0 };
    let isHovering = false;
    let animationTime = 0;
    let currentMode = 'NORMAL';
    
    // Color palette
    const colors = {
        fg: '#00ff41',
        gray: '#888888',
        green: '#8ec07c',
        yellow: '#fabd2f',
        orange: '#fe8019',
        purple: '#d3869b',
        blue: '#83a598'
    };

    function updateCanvasSize() {
        const container = canvas.parentElement;
        canvas.width = container.offsetWidth;
        canvas.height = 120; // Fixed height for header
    }

    function createParticles() {
        particles = [];
        const fontSize = 12;
        const lines = ASCII_NAME.split('\n');
        const lineHeight = fontSize * 1.2;
        const totalWidth = lines[0].length * (fontSize * 0.6);
        const startX = Math.max(10, (canvas.width - totalWidth) / 2);
        const startY = 20;
        
        lines.forEach((line, lineIndex) => {
            for (let charIndex = 0; charIndex < line.length; charIndex++) {
                const char = line[charIndex];
                if (char !== ' ') {
                    const x = startX + charIndex * (fontSize * 0.6);
                    const y = startY + lineIndex * lineHeight;
                    
                    particles.push({
                        char: char,
                        originalChar: char,
                        x: x,
                        y: y,
                        baseX: x,
                        baseY: y,
                        offsetX: 0,
                        offsetY: 0,
                        size: fontSize,
                        opacity: 0,
                        targetOpacity: 1,
                        color: colors.fg,
                        typed: false,
                        index: particles.length,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
        });
    }

    function animate() {
        if (!document.body.classList.contains('digital-view')) {
            requestAnimationFrame(animate);
            return;
        }
        
        animationTime++;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = '12px monospace';

        particles.forEach((particle, index) => {
            const distance = Math.sqrt(
                Math.pow(mousePosition.x - particle.baseX, 2) + 
                Math.pow(mousePosition.y - particle.baseY, 2)
            );

            // Typing effect on load
            if (!particle.typed) {
                const typingDelay = index * 3;
                if (animationTime > typingDelay) {
                    particle.typed = true;
                    particle.targetOpacity = 1;
                }
            }

            // Smooth opacity transition
            particle.opacity += (particle.targetOpacity - particle.opacity) * 0.1;

            // Interactive fintech effects
            if (distance < 10 && isHovering) {
                switch(currentMode) {
                    case 'INSERT': // Settlement Mode
                        const settlementDay = Math.floor(animationTime / 60) % 3;
                        const dayChars = ['T', '+1', '+2'];
                        if (Math.random() < 0.3) {
                            particle.char = dayChars[settlementDay];
                        }
                        
                        if (settlementDay === 2) {
                            particle.color = colors.green;
                            particle.offsetY = Math.sin(animationTime * 0.3 + index) * 5;
                        } else {
                            particle.color = colors.orange;
                            particle.offsetY *= 0.9;
                        }
                        break;
                    
                    case 'VISUAL': // Blockchain Mode
                        const hashChars = ['0', '1', 'a', 'b', 'c', 'd', 'e', 'f'];
                        if (Math.random() < 0.2) {
                            particle.char = hashChars[Math.floor(Math.random() * hashChars.length)];
                        }
                        particle.color = colors.blue;
                        
                        // Draw blockchain connections
                        if (index > 0 && Math.random() < 0.1) {
                            ctx.strokeStyle = colors.blue;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(particles[Math.max(0, index-1)].baseX, particles[Math.max(0, index-1)].baseY);
                            ctx.lineTo(particle.baseX, particle.baseY);
                            ctx.stroke();
                        }
                        break;
                    
                    case 'COMMAND': // Risk Assessment Mode
                        particle.phase = (particle.phase || 0) + 0.15;
                        const riskLevel = Math.sin(particle.phase) * 0.5 + 0.5;
                        const riskChars = ['!', '?', '%', '∆', '∑', '∏'];
                        
                        if (Math.random() < 0.25) {
                            particle.char = riskChars[Math.floor(riskLevel * riskChars.length)];
                        }
                        
                        if (riskLevel > 0.7) {
                            particle.color = '#ff4444';
                            particle.offsetX = (Math.random() - 0.5) * 6;
                        } else if (riskLevel > 0.4) {
                            particle.color = colors.orange;
                        } else {
                            particle.color = colors.green;
                        }
                        break;
                    
                    default: // NORMAL
                        particle.color = colors.yellow;
                        particle.offsetX = Math.sin(animationTime * 0.05 + index) * 1;
                        break;
                }
            } else {
                particle.char = particle.originalChar || particle.char;
                particle.color = colors.fg;
                particle.offsetX *= 0.9;
                particle.offsetY *= 0.9;
            }

            // Render particle
            ctx.fillStyle = particle.color;
            ctx.globalAlpha = particle.opacity;
            ctx.fillText(
                particle.char,
                particle.baseX + particle.offsetX,
                particle.baseY + particle.offsetY
            );
        });

        ctx.globalAlpha = 1;
        requestAnimationFrame(animate);
    }

    // Event listeners
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePosition.x = e.clientX - rect.left;
        mousePosition.y = e.clientY - rect.top;
        isHovering = true;
        
    });

    canvas.addEventListener('mouseleave', () => {
        isHovering = false;
    });

    // Vim mode switching
    document.addEventListener('keydown', (e) => {
        if (!document.body.classList.contains('digital-view')) return;
        
        if (e.key === 'Escape') {
            currentMode = 'NORMAL';
        } else if (currentMode === 'NORMAL') {
            if (e.key === 'i') currentMode = 'INSERT';
            else if (e.key === 'v') currentMode = 'VISUAL';
            else if (e.key === ':') currentMode = 'COMMAND';
        }
        
        if (modeElement) {
            modeElement.textContent = currentMode;
            modeElement.className = `vim-mode digital-only ${currentMode.toLowerCase()}`;
        }
    });

    // Initialize
    updateCanvasSize();
    createParticles();
    animate();

    window.addEventListener('resize', () => {
        updateCanvasSize();
        createParticles();
    });
}

// Initialize when DOM is loaded and in digital view
document.addEventListener('DOMContentLoaded', () => {
    initInteractiveASCII();
    
    // Re-initialize when switching views
    const observer = new MutationObserver(() => {
        setTimeout(initInteractiveASCII, 100);
    });
    observer.observe(document.body, { 
        attributes: true, 
        attributeFilter: ['class'] 
    });
});
</script>

