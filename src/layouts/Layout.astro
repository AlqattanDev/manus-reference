---
import '../styles/design-system.css';
import '../styles/themes.css';
import '../styles/global.css';
import '../styles/page-breaks.css';
import ProgressBar from '../components/layout/ProgressBar.astro';
import StatusBar from '../components/layout/StatusBar.astro';
import ScrollToTop from '../components/layout/ScrollToTop.astro';
import type { UserProfile } from '@/types/index.ts';

// Import profile data
import profileData from '../data/profile.json';

export const profile: UserProfile = profileData as UserProfile;
---

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ali - System Architect</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body class="digital-view">
    <!-- Progress Bar -->
    <ProgressBar />

    <!-- Bottom Status Bar Navigation -->
    <StatusBar />

    <!-- Scroll to Top Button -->
    <ScrollToTop />

    <div class="container page">
      <div class="content">
        <slot />
      </div>
    </div>

    <!-- Screen Reader Announcements -->
    <div id="sr-announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <script>
      // Core theme management functionality
      const themeToggle = document.getElementById('themeToggle');
      const html = document.documentElement;

      function updateTheme(theme: string) {
        try {
          html.setAttribute('data-theme', theme);
          
          // Safe localStorage operation
          try {
            localStorage.setItem('theme', theme);
          } catch (storageError) {
            console.warn('Failed to save theme preference:', storageError);
          }
        } catch (error) {
          console.error('Failed to update theme:', error);
        }
      }

      // Initialize theme with fallback
      function initializeTheme() {
        let savedTheme = 'light'; // Default fallback
        
        try {
          if (typeof Storage !== 'undefined') {
            savedTheme = localStorage.getItem('theme') || 'light';
          }
        } catch (error) {
          console.warn('localStorage not available, using default theme:', error);
        }
        
        // Validate theme value
        if (!['light', 'dark'].includes(savedTheme)) {
          savedTheme = 'light';
        }
        
        updateTheme(savedTheme);
      }

      initializeTheme();

      if (themeToggle) {
        // Get reference to the animation system
        const animationSystem = (window as any).asciiAnimationSystem;
        
        const toggleTheme = () => {
          try {
            // If animation system exists, use it to cycle schemes
            if (animationSystem) {
              animationSystem.nextScheme();
            } else {
              // Fallback to simple toggle if animation system not available
              const currentTheme = html.getAttribute('data-theme') || 'light';
              const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
              updateTheme(newTheme);
            }
            
            // Add subtle animation feedback
            themeToggle.style.transform = 'scale(0.95)';
            setTimeout(() => {
              themeToggle.style.transform = '';
            }, 150);
          } catch (error) {
            console.error('Failed to toggle theme:', error);
          }
        };
        
        // Listen for theme:changed events from the animation system
        document.addEventListener('theme:changed', (e: Event) => {
          const customEvent = e as CustomEvent;
          if (customEvent.detail && customEvent.detail.theme) {
            themeToggle.setAttribute('aria-pressed', customEvent.detail.theme === 'dark' ? 'true' : 'false');
          }
        });
        
        themeToggle.addEventListener('click', toggleTheme);
        
        // Add keyboard support
        themeToggle.addEventListener('keydown', (e) => {
          const keyEvent = e as KeyboardEvent;
          if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
            keyEvent.preventDefault();
            toggleTheme();
          }
        });
      }

      // Lazy load section observer with performance optimization
      const observeSections = () => {
        const navLinks = Array.from(document.querySelectorAll('.status-item')) as HTMLAnchorElement[];
        if (navLinks.length === 0) return;
        
        const sections = navLinks
          .map((l) => document.querySelector(l.getAttribute('href')!) as HTMLElement | null)
          .filter(Boolean) as HTMLElement[];
          
        if (sections.length === 0) return;
        
        // Debounce utility
        function debounce(func: Function, wait: number) {
          let timeout: NodeJS.Timeout;
          return function executedFunction(...args: any[]) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        }
        
        // Debounced intersection handler
        const debouncedHandler = debounce((entries: IntersectionObserverEntry[]) => {
          entries.forEach((entry) => {
            const id = entry.target.getAttribute('id');
            if (!id) return;
            const link = navLinks.find((l) => l.getAttribute('href') === `#${id}`);
            if (!link) return;
            if (entry.isIntersecting) {
              requestAnimationFrame(() => {
                navLinks.forEach((a) => a.classList.remove('active'));
                link.classList.add('active');
              });
            }
          });
        }, 50);
        
        const observer = new IntersectionObserver(
          debouncedHandler,
          { rootMargin: '-40% 0px -55% 0px', threshold: [0, 0.25, 0.6, 1] }
        );
        
        sections.forEach((sec) => observer.observe(sec));
      };

      // Initialize section observer after a short delay
      setTimeout(observeSections, 100);
    </script>

    <style is:global>
      /* Core layout styles */
      * { 
        margin: 0; 
        padding: 0; 
        box-sizing: border-box; 
      }

      body {
        font-family: var(--font-body);
        line-height: var(--line-height-base);
        transition: 
          background-color var(--transition-base) var(--ease-in-out),
          color var(--transition-base) var(--ease-in-out);
        overflow-x: hidden;
        position: relative;
      }

      /* Smooth transitions for all interactive elements */
      .section-title,
      .entry-title,
      .entry-meta,
      .entry-description,
      .contact-title,
      .contact-meta,
      .contact-description,
      .tech-tag,
      .checksum,
      a {
        transition:
          color var(--transition-base) var(--ease-in-out),
          border-color var(--transition-base) var(--ease-in-out),
          background-color var(--transition-base) var(--ease-in-out);
      }

      /* Ambient grid background in digital view */
      body.digital-view::before {
        content: '';
        position: fixed;
        inset: 0;
        background:
          linear-gradient(90deg, rgba(0,255,65,0.08) 1px, transparent 1px) 0 0 / 40px 40px,
          linear-gradient(0deg, rgba(0,255,65,0.06) 1px, transparent 1px) 0 0 / 40px 40px;
        pointer-events: none;
        z-index: var(--z-base);
        opacity: 0.25;
      }

      /* View modes */
      body.digital-view { 
        background: var(--background-digital); 
        color: var(--foreground-digital); 
      }

      body.print-view { 
        background: var(--background-print); 
        color: var(--foreground-print); 
      }

      /* Layout container */
      .container { 
        max-width: var(--container-lg); 
        margin: 0 auto; 
        padding: var(--space-4xl) var(--space-lg) var(--space-2xl); 
        position: relative; 
        z-index: var(--z-base); 
      }

      .page { 
        min-height: 100vh; 
      }


      /* Mobile adjustments */
      @media (max-width: 768px) {
        .container { 
          padding: var(--space-3xl) var(--space-md) var(--space-2xl); 
        }
      }

      @media (max-width: 480px) {
        .container { 
          padding: var(--space-3xl) var(--space-sm) var(--space-2xl); 
        }
      }

      /* Hide digital-only elements when printing */
      @media print {
        .digital-only { 
          display: none !important; 
        }
      }
    </style>
  </body>
</html>