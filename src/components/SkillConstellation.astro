---
interface Props {
  skills: {
    header: string;
    items: {
      name: string;
    }[];
  }[];
}

const { skills } = Astro.props as Props;
---

<div class="skill-constellation">
  <canvas id="skill-canvas"></canvas>
</div>

<style>
  .skill-constellation {
    position: relative;
    width: 100%;
    height: 500px; /* Adjust as needed */
  }

  #skill-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
</style>

<script define:vars={{ skills }}>
  const canvas = document.getElementById('skill-canvas');
  const ctx = canvas.getContext('2d');

  let particles = [];
  let themeColors = {
    primary: 'rgba(255, 255, 255, 1)',
    secondary: 'rgba(255, 255, 255, 0.7)',
    connection: 'rgba(255, 255, 255, 0.1)',
    text: 'rgba(255, 255, 255, 1)'
  };

  // Get theme colors from CSS variables
  function updateThemeColors() {
    const style = getComputedStyle(document.documentElement);
    const primaryRgb = style.getPropertyValue('--space-primary-rgb').trim();
    const secondaryRgb = style.getPropertyValue('--space-secondary-rgb').trim();
    const foregroundRgb = style.getPropertyValue('--foreground-digital').trim();
    
    if (primaryRgb) {
      themeColors.primary = `rgba(${primaryRgb}, 1)`;
      themeColors.secondary = `rgba(${primaryRgb}, 0.8)`;
      themeColors.connection = `rgba(${primaryRgb}, 0.15)`;
    }
    
    if (foregroundRgb) {
      // Convert hex to rgb if needed
      let rgbValue = foregroundRgb;
      if (foregroundRgb.startsWith('#')) {
        const hex = foregroundRgb.slice(1);
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        rgbValue = `${r}, ${g}, ${b}`;
      } else if (foregroundRgb.startsWith('rgb')) {
        rgbValue = foregroundRgb.match(/\d+/g).join(', ');
      }
      themeColors.text = `rgba(${rgbValue}, 1)`;
    }

    if (secondaryRgb) {
      themeColors.secondary = `rgba(${secondaryRgb}, 0.9)`;
    }
  }

  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;

  // Update colors when theme changes
  document.addEventListener('theme:changed', updateThemeColors);
  
  // Initial color setup
  updateThemeColors();

  class Particle {
    constructor(x, y, radius, name, colorType = 'primary') {
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.colorType = colorType;
      this.name = name;
      this.vx = (Math.random() - 0.5) * 2;
      this.vy = (Math.random() - 0.5) * 2;
      this.pulsePhase = Math.random() * Math.PI * 2;
      this.pulseSpeed = 0.02;
    }

    draw() {
      // Dynamic pulsing effect
      const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
      const currentRadius = this.radius * pulse;
      
      // Get current theme color
      const color = themeColors[this.colorType] || themeColors.primary;
      
      // Draw main particle
      ctx.beginPath();
      ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      
      // Draw subtle glow effect
      ctx.beginPath();
      ctx.arc(this.x, this.y, currentRadius + 2, 0, Math.PI * 2);
      ctx.fillStyle = color.replace(/[\d\.]+\)$/g, '0.3)');
      ctx.fill();
      
      this.pulsePhase += this.pulseSpeed;
    }

    update() {
      this.x += this.vx;
      this.y += this.vy;

      if (this.x < this.radius || this.x > canvas.width - this.radius) {
        this.vx = -this.vx;
      }

      if (this.y < this.radius || this.y > canvas.height - this.radius) {
        this.vy = -this.vy;
      }
    }
  }

  function init() {
    particles = [];
    skills.forEach((category, categoryIndex) => {
      category.items.forEach((skill, skillIndex) => {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const radius = Math.random() * 3 + 4; // 4-7px radius
        // Alternate between primary and secondary colors for variety
        const colorType = (categoryIndex + skillIndex) % 2 === 0 ? 'primary' : 'secondary';
        particles.push(new Particle(x, y, radius, skill.name, colorType));
      });
    });
  }

  function animate() {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    particles.forEach(particle => {
      particle.update();
      particle.draw();
    });

    connect();
  }

  function connect() {
    for (let a = 0; a < particles.length; a++) {
      for (let b = a; b < particles.length; b++) {
        const distance = Math.sqrt(
          (particles[a].x - particles[b].x) ** 2 +
          (particles[a].y - particles[b].y) ** 2
        );

        if (distance < 120) {
          // Calculate connection opacity based on distance
          const opacity = (120 - distance) / 120 * 0.2;
          
          // Use theme-aware connection color
          ctx.strokeStyle = themeColors.connection.replace(/[\d\.]+\)$/g, `${opacity})`);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(particles[a].x, particles[a].y);
          ctx.lineTo(particles[b].x, particles[b].y);
          ctx.stroke();
        }
      }
    }
  }

  // Tooltip functionality
  let hoveredParticle = null;
  
  canvas.addEventListener('mousemove', (event) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    // Find hovered particle
    hoveredParticle = null;
    particles.forEach(particle => {
      const distance = Math.sqrt(
        (particle.x - mouseX) ** 2 + (particle.y - mouseY) ** 2
      );

      if (distance < particle.radius + 8) {
        hoveredParticle = particle;
      }
    });
  });

  // Enhanced animation loop with tooltips
  function animate() {
    requestAnimationFrame(animate);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    particles.forEach(particle => {
      particle.update();
      particle.draw();
    });

    connect();

    // Draw tooltip for hovered particle
    if (hoveredParticle) {
      const padding = 8;
      const fontSize = 14;
      ctx.font = `${fontSize}px var(--font-mono, monospace)`;
      
      // Measure text for background
      const textWidth = ctx.measureText(hoveredParticle.name).width;
      const textHeight = fontSize;
      
      // Position tooltip
      let tooltipX = hoveredParticle.x + 15;
      let tooltipY = hoveredParticle.y - 15;
      
      // Keep tooltip in canvas bounds
      if (tooltipX + textWidth + padding * 2 > canvas.width) {
        tooltipX = hoveredParticle.x - textWidth - padding * 2 - 15;
      }
      if (tooltipY - textHeight - padding * 2 < 0) {
        tooltipY = hoveredParticle.y + textHeight + padding * 2 + 15;
      }
      
      // Draw tooltip background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(tooltipX - padding, tooltipY - textHeight - padding, 
                  textWidth + padding * 2, textHeight + padding * 2);
      
      // Draw tooltip border
      ctx.strokeStyle = themeColors.primary;
      ctx.lineWidth = 1;
      ctx.strokeRect(tooltipX - padding, tooltipY - textHeight - padding, 
                    textWidth + padding * 2, textHeight + padding * 2);
      
      // Draw tooltip text
      ctx.fillStyle = themeColors.text;
      ctx.fillText(hoveredParticle.name, tooltipX, tooltipY);
    }
  }

  // Handle window resize
  window.addEventListener('resize', () => {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    
    // Reposition particles within new bounds
    particles.forEach(particle => {
      if (particle.x > canvas.width) particle.x = canvas.width - particle.radius;
      if (particle.y > canvas.height) particle.y = canvas.height - particle.radius;
    });
  });

  // Handle reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
  
  if (prefersReducedMotion.matches) {
    // Disable particle movement for reduced motion
    particles.forEach(particle => {
      particle.vx = 0;
      particle.vy = 0;
      particle.pulseSpeed = 0;
    });
  }

  init();
  animate();
</script>
